Index: algorithm
===================================================================
--- algorithm	(revision 91)
+++ algorithm	(working copy)
@@ -9,6 +9,41 @@
  #pragma warning(push,3)
  #pragma warning(disable: 4244)
 
+/* ------------------------------------------------------------------------ */
+/* Forward declare these now because they are used as non-dependent names.  */
+_STDEXT_BEGIN
+template<class _InIt, class _OutIt, class _Ty>
+inline _OutIt unchecked_remove_copy(_InIt _First, _InIt _Last,
+                                    _OutIt _Dest, const _Ty& _Val);
+template<class _InIt, class _OutIt, class _Pr>
+inline _OutIt unchecked_remove_copy_if(_InIt _First, _InIt _Last,
+                                       _OutIt _Dest, _Pr _Pred);
+template<class _InIt1, class _InIt2, class _OutIt>
+inline _OutIt unchecked_merge(_InIt1 _First1, _InIt1 _Last1,
+                              _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
+template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
+inline _OutIt unchecked_merge(_InIt1 _First1, _InIt1 _Last1,
+                              _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest,
+                              _Pr _Pred);
+template<class _BidIt1, class _BidIt2, class _BidIt3>
+inline _BidIt3 _Unchecked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
+                                         _BidIt2 _First2, _BidIt2 _Last2,
+                                         _BidIt3 _Dest);
+template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
+inline _BidIt3 _Unchecked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
+                                         _BidIt2 _First2, _BidIt2 _Last2,
+                                         _BidIt3 _Dest, _Pr _Pred);
+template<class _BidIt, class _OutIt, class _Diff>
+inline void _Unchecked_chunked_merge(_BidIt _First, _BidIt _Last,
+                                     _OutIt _Dest, _Diff _Chunk,
+                                     _Diff _Count);
+template<class _BidIt, class _OutIt, class _Diff, class _Pr>
+inline void _Unchecked_chunked_merge(_BidIt _First, _BidIt _Last,
+                                     _OutIt _Dest, _Diff _Chunk,
+                                     _Diff _Count, _Pr _Pred);
+_STDEXT_END
+/* ------------------------------------------------------------------------ */
+
 _STD_BEGIN
 		// COMMON SORT PARAMETERS
 const int _ISORT_MAX = 32;	// maximum size for insertion sort
@@ -2400,7 +2435,7 @@
   #define _DEBUG_HEAP(first, last)
   #define _DEBUG_HEAP_PRED(first, last, pred)
  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
-
+/*
 		// TEMPLATE FUNCTION push_heap
 template<class _RanIt,
 	class _Diff,
@@ -2418,7 +2453,7 @@
 
 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole
 	}
-
+*/
 template<class _RanIt,
 	class _Diff,
 	class _Ty> inline
@@ -2444,7 +2479,7 @@
 			_Dist_type(_First), _Val_type(_First));
 		}
 	}
-
+/*
 		// TEMPLATE FUNCTION push_heap WITH PRED
 template<class _RanIt,
 	class _Diff,
@@ -2463,7 +2498,7 @@
 
 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole
 	}
-
+*/
 template<class _RanIt,
 	class _Diff,
 	class _Ty,
@@ -2492,7 +2527,7 @@
 			_Dist_type(_First), _Val_type(_First));
 		}
 	}
-
+/*
 		// TEMPLATE FUNCTION pop_heap
 template<class _RanIt,
 	class _Diff,
@@ -2529,7 +2564,7 @@
 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
 		_Move(_Val));
 	}
-
+*/
 template<class _RanIt,
 	class _Ty> inline
 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Ty *)
@@ -2554,7 +2589,7 @@
 	if (1 < _Last - _First)
 		_Pop_heap(_Unchecked(_First), _Unchecked(_Last));
 	}
-
+/*
 		// TEMPLATE FUNCTION pop_heap WITH PRED
 template<class _RanIt,
 	class _Diff,
@@ -2593,7 +2628,7 @@
 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
 		_Move(_Val), _Pred);
 	}
-
+*/
 template<class _RanIt,
 	class _Ty,
 	class _Pr> inline
Index: bitset
===================================================================
--- bitset	(revision 91)
+++ bitset	(working copy)
@@ -478,9 +478,9 @@
 
 	void _Trim()
 		{	// clear any trailing bits in last word
-		_Trim_if<_Bits % _Bitsperword != 0>();
+		//_Trim_if<_Bits % _Bitsperword != 0>();
 		}
-
+/*
 	template<bool _Has_bits>
 		void _Trim_if()
 		{	// bits to trim, remove them
@@ -491,7 +491,7 @@
 		void _Trim_if<false>()
 		{	// no bits to trim, do nothing
 		}
-
+*/
 	__declspec(noreturn) void _Xinv() const
 		{	// report invalid string element in bitset conversion
 		_Xinvalid_argument("invalid bitset<N> char");
Index: CodeAnalysis/sourceannotations.h
===================================================================
--- CodeAnalysis/sourceannotations.h	(revision 91)
+++ CodeAnalysis/sourceannotations.h	(working copy)
@@ -42,7 +42,7 @@
 
 #ifdef __cplusplus
 #define SA( id ) id
-#define REPEATABLE [repeatable]
+#define REPEATABLE
 #else  // !__cplusplus
 #define SA( id ) SA_##id
 #define REPEATABLE
@@ -76,7 +76,7 @@
 #ifndef SAL_NO_ATTRIBUTE_DECLARATIONS
 
 REPEATABLE
-[source_annotation_attribute( SA( Parameter ) )]
+////[source_annotation_attribute( SA( Parameter ) )]
 struct PreAttribute
 {
 #ifdef __cplusplus
@@ -107,7 +107,7 @@
 };
 
 REPEATABLE
-[source_annotation_attribute( SA( Parameter )|SA( ReturnValue ) )]
+////[source_annotation_attribute( SA( Parameter )|SA( ReturnValue ) )]
 struct PostAttribute
 {
 #ifdef __cplusplus
@@ -138,7 +138,7 @@
 	const wchar_t* Condition;
 };
 
-[source_annotation_attribute( SA( Parameter ) )]
+//[source_annotation_attribute( SA( Parameter ) )]
 struct FormatStringAttribute
 {
 #ifdef __cplusplus
@@ -150,7 +150,7 @@
 };
 
 REPEATABLE
-[source_annotation_attribute( SA( ReturnValue ) )]
+//[source_annotation_attribute( SA( ReturnValue ) )]
 struct InvalidCheckAttribute
 {
 #ifdef __cplusplus
@@ -160,7 +160,7 @@
 	long Value;
 };
 
-[source_annotation_attribute( SA( Method ) )]
+//[source_annotation_attribute( SA( Method ) )]
 struct SuccessAttribute
 {
 #ifdef __cplusplus
@@ -171,7 +171,7 @@
 };
 
 REPEATABLE
-[source_annotation_attribute( SA( Parameter ) )]
+//[source_annotation_attribute( SA( Parameter ) )]
 struct PreBoundAttribute
 {
 #ifdef __cplusplus
@@ -181,7 +181,7 @@
 };
 
 REPEATABLE
-[source_annotation_attribute( SA( Parameter )|SA( ReturnValue ) )]
+//[source_annotation_attribute( SA( Parameter )|SA( ReturnValue ) )]
 struct PostBoundAttribute
 {
 #ifdef __cplusplus
@@ -191,7 +191,7 @@
 };
 
 REPEATABLE
-[source_annotation_attribute( SA( Parameter ) )]
+//[source_annotation_attribute( SA( Parameter ) )]
 struct PreRangeAttribute
 {
 #ifdef __cplusplus
@@ -203,7 +203,7 @@
 };
 
 REPEATABLE
-[source_annotation_attribute( SA( Parameter )|SA( ReturnValue ) )]
+//[source_annotation_attribute( SA( Parameter )|SA( ReturnValue ) )]
 struct PostRangeAttribute
 {
 #ifdef __cplusplus
Index: deque
===================================================================
--- deque	(revision 91)
+++ deque	(working copy)
@@ -729,7 +729,7 @@
 		typename _Alloc::template rebind<_Container_proxy>::other
 			_Alproxy(_Alval);
 		this->_Myproxy = _Alproxy.allocate(1);
-		_Cons_val(_Alproxy, this->_Myproxy, _Container_proxy());
+		//_Cons_val(_Alproxy, this->_Myproxy, _Container_proxy());
 		this->_Myproxy->_Mycont = this;
 
 		_Map = 0;
@@ -901,7 +901,7 @@
 
 #define _PUSH_BACK_END \
 	++this->_Mysize
-
+/*
 	deque(_Myt&& _Right)
 		: _Mybase(_Right._Alval)
 		{	// construct by moving _Right
@@ -997,7 +997,7 @@
  #if _ITERATOR_DEBUG_LEVEL == 2
 		if (this->_Mysize < _Off)
 			_DEBUG_ERROR("deque emplace iterator outside range");
- #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
+ #endif /* _ITERATOR_DEBUG_LEVEL == 2 * /
 
 		if (_Off <= this->_Mysize / 2)
 			{	// closer to front, push to front then rotate
@@ -1016,7 +1016,7 @@
 		{	// exchange contents with movable _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	~deque()
 		{	// destroy the deque
 		_Tidy();
@@ -1686,7 +1686,7 @@
 	{	// swap _Left and _Right deques
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Ty,
 	class _Alloc> inline
 	void swap(deque<_Ty, _Alloc>& _Left, deque<_Ty, _Alloc>&& _Right)
@@ -1702,7 +1702,7 @@
 	typedef deque<_Ty, _Alloc> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 template<class _Ty,
 	class _Alloc> inline
 	bool operator==(const deque<_Ty, _Alloc>& _Left,
Index: eh.h
===================================================================
--- eh.h	(revision 91)
+++ eh.h	(working copy)
@@ -27,6 +27,9 @@
 #error "eh.h is only for C++!"
 #endif
 
+namespace std { class type_info; }
+using std::type_info;
+
 /* terminate_handler is the standard name; terminate_function is supported for historical reasons */
 #ifndef _M_CEE_PURE
 typedef void (__cdecl *terminate_function)();
Index: fstream
===================================================================
--- fstream	(revision 91)
+++ fstream	(working copy)
@@ -161,7 +161,7 @@
 		: _Mysb(_Noinit)
 		{	// construct uninitialized
 		}
-
+/*
 	basic_filebuf(_Myt&& _Right)
 		{	// construct by copying _Right
 		_Init(_Right._Myfile, _Newfl);	// match buffering styles
@@ -183,7 +183,7 @@
 			this->swap(_Right);
 			}
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// swap with _Right
 		if (this != &_Right)
@@ -197,12 +197,12 @@
 			_STD swap(_Myfile, _Right._Myfile);
 			}
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// swap with _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	enum _Initfl
 		{	// reasons for a call to _Init
 		_Newfl, _Openfl, _Closefl};
@@ -671,7 +671,7 @@
 	{	// swap _Left and _Right basic_filebufs
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Elem,
 	class _Traits> inline
 	void swap(basic_filebuf<_Elem, _Traits>& _Left,
@@ -689,7 +689,7 @@
 	typedef basic_filebuf<_Elem, _Traits> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 		// TEMPLATE CLASS basic_ifstream
 template<class _Elem,
 	class _Traits>
@@ -763,7 +763,7 @@
 			_Filebuffer(_File)
 		{	// construct with specified C stream
 		}
-
+/*
 	basic_ifstream(_Myt&& _Right)
 		: _Mybase(&_Filebuffer)
 		{	// construct by moving _Right
@@ -784,7 +784,7 @@
 			this->swap(_Right);
 			}
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// swap with _Right
 		if (this != &_Right)
@@ -793,7 +793,7 @@
 			_Filebuffer.swap(_Right._Filebuffer);
 			}
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// swap with _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
@@ -808,7 +808,7 @@
 		else
 			_Myios::clear();	// added with C++0X
 		}
-
+*/
  #if _HAS_CPP0X
 	void open(const wstring& _Str,
 		ios_base::openmode _Mode = ios_base::in,
@@ -897,7 +897,7 @@
 	{	// swap _Left and _Right basic_ifstreams
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Elem,
 	class _Traits> inline
 	void swap(basic_ifstream<_Elem, _Traits>& _Left,
@@ -915,7 +915,7 @@
 	typedef basic_ifstream<_Elem, _Traits> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 		// TEMPLATE CLASS basic_ofstream
 template<class _Elem,
 	class _Traits>
@@ -989,7 +989,7 @@
 			_Filebuffer(_File)
 		{	// construct with specified C stream
 		}
-
+/*
 	basic_ofstream(_Myt&& _Right)
 		: _Mybase(&_Filebuffer)
 		{	// construct by moving _Right
@@ -1010,7 +1010,7 @@
 			this->swap(_Right);
 			}
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// swap with _Right
 		if (this != &_Right)
@@ -1019,12 +1019,12 @@
 			_Filebuffer.swap(_Right._Filebuffer);
 			}
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// swap with _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	void open(const wchar_t *_Filename,
 		ios_base::openmode _Mode = ios_base::out,
 		int _Prot = (int)ios_base::_Openprot)
@@ -1123,7 +1123,7 @@
 	{	// swap _Left and _Right basic_ofstreams
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Elem,
 	class _Traits> inline
 	void swap(basic_ofstream<_Elem, _Traits>& _Left,
@@ -1141,7 +1141,7 @@
 	typedef basic_ofstream<_Elem, _Traits> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 		// TEMPLATE CLASS basic_fstream
 template<class _Elem,
 	class _Traits>
@@ -1220,7 +1220,7 @@
 			_Filebuffer(_File)
 		{	// construct with specified C stream
 		}
-
+/*
 	basic_fstream(_Myt&& _Right)
 		: _Mybase(&_Filebuffer)
 		{	// construct by moving _Right
@@ -1241,7 +1241,7 @@
 			this->swap(_Right);
 			}
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// swap with _Right
 		if (this != &_Right)
@@ -1250,12 +1250,12 @@
 			_Filebuffer.swap(_Right._Filebuffer);
 			}
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// swap with _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	void open(const wchar_t *_Filename,
 		ios_base::openmode _Mode = ios_base::in | ios_base::out,
 		int _Prot = (int)ios_base::_Openprot)
@@ -1354,7 +1354,7 @@
 	{	// swap _Left and _Right basic_fstreams
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Elem,
 	class _Traits> inline
 	void swap(basic_fstream<_Elem, _Traits>& _Left,
@@ -1371,7 +1371,7 @@
 	{	// swap _Left and _Right basic_fstreams
 	typedef basic_fstream<_Elem, _Traits> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
-	}
+	}*/
 _STD_END
 
  #pragma warning(pop)
Index: hash_map
===================================================================
--- hash_map	(revision 91)
+++ hash_map	(working copy)
@@ -166,7 +166,7 @@
 		_Mybase::operator=(_Right);
 		return (*this);
 		}
-
+/*
 	hash_map(_Myt&& _Right)
 		: _Mybase(_STD move(_Right))
 		{	// construct map by moving _Right
@@ -188,17 +188,17 @@
 					mapped_type())).first;
 		return ((*_Where).second);
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// exchange contents with non-movable _Right
 		_Mybase::swap(_Right);
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// exchange contents with movable _Right
 		_Mybase::swap(_STD move(_Right));
 		}
-
+*/
 	mapped_type& operator[](const key_type& _Keyval)
 		{	// find element matching _Keyval or insert with default mapped
 		iterator _Where = this->lower_bound(_Keyval);
@@ -235,7 +235,7 @@
 	{	// swap _Left and _Right hash_maps
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Kty,
 	class _Ty,
 	class _Tr,
@@ -256,7 +256,7 @@
 	{	// swap _Left and _Right hash_maps
 	typedef hash_map<_Kty, _Ty, _Tr, _Alloc> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
-	}
+	}*/
 }	// namespace stdext
 _STD_BEGIN
 using stdext::hash_map;
@@ -349,7 +349,7 @@
 		_Mybase::operator=(_Right);
 		return (*this);
 		}
-
+/*
 	hash_multimap(_Myt&& _Right)
 		: _Mybase(_STD move(_Right))
 		{	// construct map by moving _Right
@@ -375,17 +375,17 @@
 		{	// insert a {key, mapped} value, with hint
 		return (_Mybase::insert(_Where, _STD forward<_Valty>(_Val)));
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// exchange contents with non-movable _Right
 		_Mybase::swap(_Right);
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// exchange contents with movable _Right
 		_Mybase::swap(_STD move(_Right));
 		}
-
+*/
 	iterator insert(const value_type& _Val)
 		{	// insert a {key, mapped} value
 		return (_Mybase::insert(_Val).first);
@@ -413,7 +413,7 @@
 	{	// swap _Left and _Right hash_multimaps
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Kty,
 	class _Ty,
 	class _Tr,
@@ -434,7 +434,7 @@
 	{	// swap _Left and _Right hash_multimaps
 	typedef hash_multimap<_Kty, _Ty, _Tr, _Alloc> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
-	}
+	}*/
 }	// namespace stdext
 _STD_BEGIN
 using stdext::hash_multimap;
Index: hash_set
===================================================================
--- hash_set	(revision 91)
+++ hash_set	(working copy)
@@ -138,7 +138,7 @@
 		_Mybase::operator=(_Right);
 		return (*this);
 		}
-
+/*
 	hash_set(_Myt&& _Right)
 		: _Mybase(_STD move(_Right))
 		{	// construct set by moving _Right
@@ -149,16 +149,16 @@
 		_Mybase::operator=(_STD move(_Right));
 		return (*this);
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// exchange contents with non-movable _Right
 		_Mybase::swap(_Right);
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// exchange contents with movable _Right
 		_Mybase::swap(_STD move(_Right));
-		}
+		}*/
 	};
 
 template<class _Kty,
@@ -169,7 +169,7 @@
 	{	// swap _Left and _Right hash_sets
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Kty,
 	class _Tr,
 	class _Alloc> inline
@@ -188,7 +188,7 @@
 	{	// swap _Left and _Right hash_sets
 	typedef hash_set<_Kty, _Tr, _Alloc> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
-	}
+	}*/
 }	// namespace stdext
 _STD_BEGIN
 using stdext::hash_set;
@@ -277,7 +277,7 @@
 		_Mybase::operator=(_Right);
 		return (*this);
 		}
-
+/*
 	hash_multiset(_Myt&& _Right)
 		: _Mybase(_STD move(_Right))
 		{	// construct set by moving _Right
@@ -303,17 +303,17 @@
 		{	// insert a {key, mapped} value, with hint
 		return (_Mybase::insert(_Where, _STD forward<_Valty>(_Val)));
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// exchange contents with non-movable _Right
 		_Mybase::swap(_Right);
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// exchange contents with movable _Right
 		_Mybase::swap(_STD move(_Right));
 		}
-
+*/
 	iterator insert(const value_type& _Val)
 		{	// insert a key value
 		return (_Mybase::insert(_Val).first);
@@ -340,7 +340,7 @@
 	{	// swap _Left and _Right hash_multisets
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Kty,
 	class _Tr,
 	class _Alloc> inline
@@ -359,7 +359,7 @@
 	{	// swap _Left and _Right hash_multisets
 	typedef hash_multiset<_Kty, _Tr, _Alloc> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
-	}
+	}*/
 }	// namespace stdext
 _STD_BEGIN
 using stdext::hash_multiset;
Index: ios
===================================================================
--- ios	(revision 91)
+++ ios	(working copy)
@@ -125,7 +125,7 @@
 		const _Ctype& _Ctype_fac = _USE(getloc(), _Ctype);
 		return (_Ctype_fac.widen(_Byte));
 		}
-
+/*
 	void __CLR_OR_THIS_CALL move(_Myt&& _Right)
 		{	// assign by moving _Right
 		if (this != &_Right)
@@ -135,7 +135,7 @@
 			this->swap(_Right);
 			}
 		}
-
+*/
 	void __CLR_OR_THIS_CALL swap(_Myt& _Right)
 		{	// swap all but rdbuf() with right
 		ios_base::swap(_Right);
Index: istream
===================================================================
--- istream	(revision 91)
+++ istream	(working copy)
@@ -38,7 +38,7 @@
 		{	// construct uninitialized
 		ios_base::_Addstd(this);
 		}
-
+/*
 	__CLR_OR_THIS_CALL basic_istream(_Myt&& _Right)
 		: _Chcount(_Right._Chcount)
 		{	// construct by moving _Right
@@ -52,7 +52,7 @@
 		this->swap(_Right);
 		return (*this);
 		}
-
+*/
 	void __CLR_OR_THIS_CALL swap(_Myt& _Right)
 		{	// swap with _Right
 		_Myios::swap(_Right);
@@ -938,7 +938,7 @@
 			_Myos(_Noinit, false)
 		{	// construct from stream buffer pointer
 		}
-
+/*
 	__CLR_OR_THIS_CALL basic_iostream(_Myt&& _Right)
 		: _Myis(_Right.rdbuf(), false),
 			_Myos(_Noinit, false)
@@ -952,7 +952,7 @@
 		this->swap(_Right);
 		return (*this);
 		}
-
+*/
 	void __CLR_OR_THIS_CALL swap(_Myt& _Right)
 		{	// swap with _Right
 		if (this != &_Right)
@@ -980,7 +980,7 @@
 
 
  #endif /* defined(_DLL_CPPLIB) etc. */
-
+/*
 		// EXTRACTORS
 template<class _Elem,
 	class _Traits> inline
@@ -1076,7 +1076,7 @@
 	{	// extract an unsigned char
 	return (_Istr >> (char&)_Ch);
 	}
-
+*/
 template<class _Elem,
 	class _Traits> inline
 	basic_istream<_Elem, _Traits>& operator>>(
@@ -1120,7 +1120,7 @@
 	{	// extract an unsigned char
 	return (_STD move(_Istr) >> (char&)_Ch);
 	}
-
+/*
 template<class _Elem,
 	class _Traits,
 	class _Ty> inline
@@ -1129,7 +1129,7 @@
 	{	// extract from rvalue stream
 	return (_Istr >> _Val);
 	}
-
+*/
 		// MANIPULATORS
 template<class _Elem,
 	class _Traits> inline
Index: iterator
===================================================================
--- iterator	(revision 91)
+++ iterator	(working copy)
@@ -31,13 +31,13 @@
 		container->push_back(_Val);
 		return (*this);
 		}
-
+/*
 	_Myt& operator=(_Valty&& _Val)
 		{	// push value into container
 		container->push_back(_STD forward<_Valty>(_Val));
 		return (*this);
 		}
-
+*/
 	_Myt& operator*()
 		{	// pretend to return designated value
 		return (*this);
@@ -91,13 +91,13 @@
 		container->push_front(_Val);
 		return (*this);
 		}
-
+/*
 	_Myt& operator=(_Valty&& _Val)
 		{	// push value into container
 		container->push_front(_STD forward<_Valty>(_Val));
 		return (*this);
 		}
-
+*/
 	_Myt& operator*()
 		{	// pretend to return designated value
 		return (*this);
@@ -152,14 +152,14 @@
 		++iter;
 		return (*this);
 		}
-
+/*
 	_Myt& operator=(_Valty&& _Val)
 		{	// push value into container
 		iter = container->insert(iter, _STD forward<_Valty>(_Val));
 		++iter;
 		return (*this);
 		}
-
+*/
 	_Myt& operator*()
 		{	// pretend to return designated value
 		return (*this);
@@ -207,7 +207,7 @@
  	typedef typename iterator_traits<_RanIt>::difference_type
 		difference_type;
 	typedef _RanIt pointer;
-	typedef value_type&& reference;
+	typedef value_type& reference;
 	typedef _RanIt iterator_type;
 
 	move_iterator()
@@ -586,7 +586,7 @@
 	checked_array_iterator(_Iterator _Array, _STD size_t _Size, _STD size_t _Index = 0)
 		: _Myarray(_Array), _Mysize(_Size), _Myindex(_Index)
 		{	// construct with array, size, and optional index
-		_SCL_SECURE_ALWAYS_VALIDATE(_Index <= _Size);
+		//_SCL_SECURE_ALWAYS_VALIDATE(_Index <= _Size);
 		}
 
 	_Iterator base() const
Index: limits
===================================================================
--- limits	(revision 91)
+++ limits	(working copy)
@@ -76,18 +76,20 @@
 	_STCONS(int, radix, 0);
 	};
 
+#define __GCCXML_AVOID_MACRO_EXPANSION
+
 		// TEMPLATE CLASS numeric_limits
 template<class _Ty>
 	class numeric_limits
 		: public _Num_base
 	{	// numeric limits for arbitrary type _Ty (say little or nothing)
 public:
-	static _Ty (__CRTDECL min)() _THROW0()
+ 	static _Ty __CRTDECL min __GCCXML_AVOID_MACRO_EXPANSION() _THROW0()
 		{	// return minimum value
 		return (_Ty(0));
 		}
 
-	static _Ty (__CRTDECL max)() _THROW0()
+ 	static _Ty __CRTDECL max __GCCXML_AVOID_MACRO_EXPANSION() _THROW0()
 		{	// return maximum value
 		return (_Ty(0));
 		}
Index: list
===================================================================
--- list	(revision 91)
+++ list	(working copy)
@@ -536,7 +536,7 @@
 
 		return (_Pnode);
 		}
-
+/*
 	template<class _Valty>
 		_Nodeptr _Buynode(_Nodeptr _Next,
 		_Nodeptr _Prev, _Valty&& _Val)
@@ -555,7 +555,7 @@
 
 		return (_Pnode);
 		}
-
+*/
 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
 		{	// return reference to successor pointer in node
 		return ((_Nodepref)(*_Pnode)._Next);
@@ -683,7 +683,7 @@
 		_RERAISE;
 		_CATCH_END
 		}
-
+/*
 	list(_Myt&& _Right)
 		: _Mybase(_Right._Alval)
 		{	// construct list by copying _Right
@@ -749,7 +749,7 @@
  #if _ITERATOR_DEBUG_LEVEL == 2
 		if (_Where._Getcont() != this)
 			_DEBUG_ERROR("list insert iterator outside range");
- #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
+ #endif /* _ITERATOR_DEBUG_LEVEL == 2 * /
 
 		_Nodeptr _Pnode = _Where._Mynode();
 		_Nodeptr _Newnode =
@@ -764,7 +764,7 @@
 		{	// exchange contents with movable _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	~list()
 		{	// destroy the object
 		_Tidy();
@@ -1455,9 +1455,6 @@
 
 		else
 			{	// different allocator, copy nodes then erase source
-			for (const_iterator _Next = _First; _Next != _Last; ++_Next)
-				insert(_Where, (_Ty &&)*_Next);
-			_Right.erase(_First, _Last);
 			}
 		}
 
@@ -1549,7 +1546,7 @@
 	{	// swap _Left and _Right lists
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Ty,
 	class _Alloc> inline
 	void swap(list<_Ty, _Alloc>& _Left, list<_Ty, _Alloc>&& _Right)
@@ -1565,7 +1562,7 @@
 	typedef list<_Ty, _Alloc> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 template<class _Ty,
 	class _Alloc> inline
 	bool operator==(const list<_Ty, _Alloc>& _Left,
Index: map
===================================================================
--- map	(revision 91)
+++ map	(working copy)
@@ -149,7 +149,7 @@
 		_Mybase::operator=(_Right);
 		return (*this);
 		}
-
+/*
 	map(_Myt&& _Right)
 		: _Mybase(_STD move(_Right))
 		{	// construct map by moving _Right
@@ -172,17 +172,17 @@
 					mapped_type()));
 		return ((*_Where).second);
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// exchange contents with non-movable _Right
 		_Mybase::swap(_Right);
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// exchange contents with movable _Right
 		_Mybase::swap(_STD move(_Right));
 		}
-
+*/
  #if _HAS_CPP0X
 
  #else /* _HAS_CPP0X */
@@ -246,7 +246,7 @@
 	{	// swap _Left and _Right maps
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Kty,
 	class _Ty,
 	class _Pr,
@@ -268,7 +268,7 @@
 	typedef map<_Kty, _Ty, _Pr, _Alloc> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 		// TEMPLATE CLASS multimap
 template<class _Kty,
 	class _Ty,
@@ -346,7 +346,7 @@
 		_Mybase::operator=(_Right);
 		return (*this);
 		}
-
+/*
 	multimap(_Myt&& _Right)
 		: _Mybase(_STD move(_Right))
 		{	// construct map by moving _Right
@@ -372,17 +372,17 @@
 		{	// insert a {key, mapped} value, with hint
 		return (_Mybase::insert(_Where, _STD forward<_Valty>(_Val)));
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// exchange contents with non-movable _Right
 		_Mybase::swap(_Right);
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// exchange contents with movable _Right
 		_Mybase::swap(_STD move(_Right));
 		}
-
+*/
  #if _HAS_CPP0X
 
  #else /* _HAS_CPP0X */
@@ -434,7 +434,7 @@
 	{	// swap _Left and _Right multimaps
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Kty,
 	class _Ty,
 	class _Pr,
@@ -455,7 +455,7 @@
 	{	// swap _Left and _Right multimaps
 	typedef multimap<_Kty, _Ty, _Pr, _Alloc> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
-	}
+	}*/
 _STD_END
  #pragma warning(pop)
  #pragma pack(pop)
Index: memory
===================================================================
--- memory	(revision 91)
+++ memory	(working copy)
@@ -413,7 +413,7 @@
 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
 		_Ptr_cat(_First, _Dest)));
 	}
-
+/*
 		// TEMPLATE FUNCTION _Uninitialized_move WITH ALLOCATOR
 template<class _InIt,
 	class _FwdIt,
@@ -436,7 +436,7 @@
 	_CATCH_END
 	return (_Dest);
 	}
-
+*/
 template<class _InIt,
 	class _FwdIt,
 	class _Alloc,
@@ -771,7 +771,7 @@
 			}
 		return (*this);
 		}
-
+/*
 	_Temp_iterator<_Ty>& operator=(_Ty&& _Val)
 		{	// move or construct value into active buffer, and increment
 		if (_Pbuf->_Current < _Pbuf->_Hiwater)
@@ -785,7 +785,7 @@
 			}
 		return (*this);
 		}
-
+*/
 	_Temp_iterator<_Ty>& operator*()
 		{	// pretend to return designated value
 		return (*this);
@@ -1225,7 +1225,7 @@
 		: _Ptr(0), _Rep(0)
 		{	// construct
 		}
-
+/*
 	_Ptr_base(_Myt&& _Right)
 		: _Ptr(0), _Rep(0)
 		{	// construct _Ptr_base object that takes resource from _Right
@@ -1251,7 +1251,7 @@
 		if (this != &_Right)
 			_Swap(_Right);
 		}
-
+*/
 	long use_count() const
 		{	// return use count
 		return (_Rep ? _Rep->_Use_count() : 0);
@@ -1522,7 +1522,7 @@
 		{	// construct shared_ptr object for dynamic_pointer_cast
 		this->_Reset(_Other, _Tag);
 		}
-
+/*
 	shared_ptr(_Myt&& _Right)
 		: _Mybase(_STD forward<_Myt>(_Right))
 		{	// construct shared_ptr object that takes resource from _Right
@@ -1535,8 +1535,9 @@
 		: _Mybase(_STD forward<shared_ptr<_Ty2> >(_Right))
 		{	// construct shared_ptr object that takes resource from _Right
 		}
-
+*/
  #if _HAS_CPP0X
+ /*
 	template<class _Ux,
 		class _Dx>
 		shared_ptr(_STD unique_ptr<_Ux, _Dx>&& _Right)
@@ -1550,9 +1551,9 @@
 		{	// move from unique_ptr
 		shared_ptr(_STD move(_Right)).swap(*this);
 		return (*this);
-		}
+		}*/
  #endif /* _HAS_CPP0X */
-
+/*
 	_Myt& operator=(_Myt&& _Right)
 		{	// construct shared_ptr object that takes resource from _Right
 		shared_ptr(_STD move(_Right)).swap(*this);
@@ -1570,7 +1571,7 @@
 		{	// exchange contents with movable _Right
 		_Mybase::swap(_STD move(_Right));
 		}
-
+*/
 	~shared_ptr()
 		{	// release resource
 		this->_Decref();
@@ -1771,7 +1772,7 @@
 	{	// swap _Left and _Right shared_ptrs
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Ty>
 	void swap(shared_ptr<_Ty>& _Left,
 		shared_ptr<_Ty>&& _Right)
@@ -1785,7 +1786,7 @@
 	{	// swap _Left and _Right shared_ptrs
 	_Right.swap(_Left);
 	}
-
+*/
 template<class _Ty1,
 	class _Ty2>
 	shared_ptr<_Ty1> static_pointer_cast(const shared_ptr<_Ty2>& _Other)
@@ -2238,7 +2239,7 @@
 		: _Mybase(_Ptr, _Dt)
 		{	// construct with pointer and (maybe const) deleter&
 		}
-
+/*
 	unique_ptr(pointer _Ptr, typename tr1::remove_reference<_Dx>::type&& _Dt)
 		: _Mybase(_Ptr, _STD move(_Dt))
 		{	// construct by moving deleter
@@ -2288,7 +2289,7 @@
 				_Right.get_deleter());
 			}
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// swap elements
 		_Swap_adl(this->_Myptr, _Right._Myptr);
@@ -2394,6 +2395,7 @@
 		}
 
 public:
+/*
 	unique_ptr(pointer _Ptr, typename tr1::remove_reference<_Dx>::type&& _Dt)
 		: _Mybase(_Ptr, _STD move(_Dt))
 		{	// construct by moving deleter
@@ -2406,8 +2408,8 @@
 			_STD forward<_Dx>(_Right.get_deleter()))
 		{	// construct by moving _Right
 		}
-
-private:
+*/
+private:/*
 	template<class _Ty2,
 		class _Dx2>
 		unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right);	// not defined
@@ -2415,8 +2417,8 @@
 	template<class _Ty2,
 		class _Dx2>
 		_Myt& operator=(unique_ptr<_Ty2, _Dx2>&& _Right);	// not defined
-
-public:
+*/
+public:/*
 	_Myt& operator=(_Myt&& _Right)
 		{	// assign by moving _Right
 		if (this != &_Right)
@@ -2436,7 +2438,7 @@
 				_Right.get_deleter());
 			}
 		}
-
+*/
  #if defined(_NATIVE_NULLPTR_SUPPORTED) \
 	&& !defined(_DO_NOT_USE_NULLPTR_IN_STL)
 	unique_ptr(_STD nullptr_t)
@@ -2538,7 +2540,7 @@
 	{	// swap _Left with _Right
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Ty,
 	class _Dx>
 	void swap(unique_ptr<_Ty, _Dx>& _Left,
@@ -2554,7 +2556,7 @@
 	{	// swap _Right with rvalue _Left
 	_Right.swap(_Left);
 	}
-
+*/
 template<class _Ty1,
 	class _Dx1,
 	class _Ty2,
Index: ostream
===================================================================
--- ostream	(revision 91)
+++ ostream	(working copy)
@@ -56,7 +56,7 @@
 		if (_Addit)
 			ios_base::_Addstd(this);	// suppress for basic_iostream
 		}
-
+/*
 	__CLR_OR_THIS_CALL basic_ostream(_Myt&& _Right)
 		{	// construct by moving _Right
 		_Myios::init();
@@ -68,7 +68,7 @@
 		this->swap(_Right);
 		return (*this);
 		}
-
+*/
 	void __CLR_OR_THIS_CALL swap(_Myt& _Right)
 		{	// swap with _Right
 		if (this != &_Right)
@@ -960,7 +960,7 @@
 	{	// insert an unsigned char
 	return (_Ostr << (char)_Ch);
 	}
-
+/*
 template<class _Elem,
 	class _Traits,
 	class _Ty> inline
@@ -969,7 +969,7 @@
 	{	// insert to rvalue stream
 	return (_Ostr << _Val);
 	}
-
+*/
 		// MANIPULATORS
 template<class _Elem,
 	class _Traits> inline
Index: queue
===================================================================
--- queue	(revision 91)
+++ queue	(working copy)
@@ -44,7 +44,7 @@
 		c = _Right.c;
 		return (*this);
 		}
-
+/*
 	queue(_Myt&& _Right)
 		: c(_STD move(_Right.c))
 		{	// construct by moving _Right
@@ -76,7 +76,7 @@
 		{	// exchange contents with movable _Right
 		c.swap(_STD move(_Right.c));
 		}
-
+*/
 	bool empty() const
 		{	// test if queue is empty
 		return (c.empty());
@@ -139,7 +139,7 @@
 	{	// swap _Left and _Right queues
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Ty,
 	class _Container> inline
 	void swap(queue<_Ty, _Container>& _Left,
@@ -157,7 +157,7 @@
 	typedef queue<_Ty, _Container> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 template<class _Ty,
 	class _Container> inline
 	bool operator==(const queue<_Ty, _Container>& _Left,
@@ -270,7 +270,7 @@
 		comp = _Right.comp;
 		return (*this);
 		}
-
+/*
 	priority_queue(_Myt&& _Right)
 		: c(_STD move(_Right.c)), comp(_STD move(_Right.comp))
 		{	// construct by moving _Right
@@ -316,7 +316,7 @@
 		c.swap(_STD move(_Right.c));
 		_Swap_adl(comp, _Right.comp);
 		}
-
+*/
 	bool empty() const
 		{	// test if queue is empty
 		return (c.empty());
@@ -369,7 +369,7 @@
 	{	// swap _Left and _Right queues
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Ty,
 	class _Container,
 	class _Pr> inline
@@ -386,7 +386,7 @@
 		priority_queue<_Ty, _Container, _Pr>& _Right)
 	{	// swap _Left and _Right queues
 	_Right.swap(_Left);
-	}
+	}*/
 _STD_END
  #pragma warning(pop)
  #pragma pack(pop)
Index: rtcapi.h
===================================================================
--- rtcapi.h	(revision 91)
+++ rtcapi.h	(working copy)
@@ -22,6 +22,7 @@
 not intended for use by end-users. These functions are now declared deprecated by default
 and may be removed in a future version.
 */
+#define _CRT_ENABLE_RTC_INTERNALS
 #ifndef _CRT_ENABLE_RTC_INTERNALS
 #define _RTCINTERNAL_DEPRECATED _CRT_DEPRECATE_TEXT("These internal RTC functions are obsolete and should not be used")
 #else
Index: sal.h
===================================================================
--- sal.h	(revision 91)
+++ sal.h	(working copy)
@@ -108,7 +108,7 @@
 #ifdef _PREFAST_
 // choose attribute or __declspec implementation
 #ifndef _USE_DECLSPECS_FOR_SAL
-#define _USE_DECLSPECS_FOR_SAL 0
+#define _USE_DECLSPECS_FOR_SAL 1
 #endif
 
 #if _USE_DECLSPECS_FOR_SAL
Index: set
===================================================================
--- set	(revision 91)
+++ set	(working copy)
@@ -124,7 +124,7 @@
 		_Mybase::operator=(_Right);
 		return (*this);
 		}
-
+/*
 	set(_Myt&& _Right)
 		: _Mybase(_STD move(_Right))
 		{	// construct set by moving _Right
@@ -135,17 +135,17 @@
 		_Mybase::operator=(_STD move(_Right));
 		return (*this);
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// exchange contents with non-movable _Right
 		_Mybase::swap(_Right);
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// exchange contents with movable _Right
 		_Mybase::swap(_STD move(_Right));
 		}
-
+*/
  #if _HAS_CPP0X
 
  #else /* _HAS_CPP0X */
@@ -178,7 +178,7 @@
 	{	// swap _Left and _Right sets
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Kty,
 	class _Pr,
 	class _Alloc> inline
@@ -198,7 +198,7 @@
 	typedef set<_Kty, _Pr, _Alloc> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 		// TEMPLATE CLASS multiset
 template<class _Kty,
 	class _Pr = less<_Kty>,
@@ -274,7 +274,7 @@
 		_Mybase::operator=(_Right);
 		return (*this);
 		}
-
+/*
 	multiset(_Myt&& _Right)
 		: _Mybase(_STD move(_Right))
 		{	// construct set by moving _Right
@@ -300,17 +300,17 @@
 		{	// insert a key value, with hint
 		return (_Mybase::insert(_Where, _STD forward<_Valty>(_Val)));
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// exchange contents with non-movable _Right
 		_Mybase::swap(_Right);
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// exchange contents with movable _Right
 		_Mybase::swap(_STD move(_Right));
 		}
-
+*/
  #if _HAS_CPP0X
 
  #else /* _HAS_CPP0X */
@@ -361,7 +361,7 @@
 	{	// swap _Left and _Right multisets
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Kty,
 	class _Pr,
 	class _Alloc> inline
@@ -380,7 +380,7 @@
 	{	// swap _Left and _Right multisets
 	typedef multiset<_Kty, _Pr, _Alloc> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
-	}
+	}*/
 _STD_END
  #pragma warning(pop)
  #pragma pack(pop)
Index: setjmp.h
===================================================================
--- setjmp.h	(revision 91)
+++ setjmp.h	(working copy)
@@ -249,7 +249,7 @@
 #ifdef  __cplusplus
 extern "C"
 {
-_CRTIMP __declspec(noreturn) void __cdecl longjmp(_In_ jmp_buf _Buf, _In_ int _Value) throw(...);
+_CRTIMP __declspec(noreturn) void __cdecl longjmp(_In_ jmp_buf _Buf, _In_ int _Value);
 }
 #else
 _CRTIMP __declspec(noreturn) void __cdecl longjmp(_In_ jmp_buf _Buf, _In_ int _Value);
Index: sstream
===================================================================
--- sstream	(revision 91)
+++ sstream	(working copy)
@@ -34,7 +34,7 @@
 		{	// construct character buffer from string, mode
 		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));
 		}
-
+/*
 	basic_stringbuf(_Myt&& _Right)
 		{	// construct by moving _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
@@ -54,7 +54,7 @@
 			this->swap(_Right);
 			}
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// swap with _Right
 		if (this != &_Right)
@@ -65,12 +65,12 @@
 			_Swap_adl(_Al, _Right._Al);
 			}
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// swap with _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	virtual ~basic_stringbuf()
 		{	// destroy the object
 		_Tidy();
@@ -381,7 +381,7 @@
 	{	// swap _Left and _Right basic_stringbufs
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Elem,
 	class _Traits,
 	class _Alloc> inline
@@ -401,7 +401,7 @@
 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 		// TEMPLATE CLASS basic_istringstream
 template<class _Elem,
 	class _Traits,
@@ -428,7 +428,7 @@
 			_Stringbuffer(_Str, _Mode | ios_base::in)
 		{	// construct readable character buffer from NTCS
 		}
-
+/*
 	basic_istringstream(_Myt&& _Right)
 		: _Mybase(&_Stringbuffer)
 		{	// construct by moving _Right
@@ -449,7 +449,7 @@
 			this->swap(_Right);
 			}
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// swap with _Right
 		if (this != &_Right)
@@ -458,12 +458,12 @@
 			_Stringbuffer.swap(_Right._Stringbuffer);
 			}
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// swap with _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	virtual ~basic_istringstream()
 		{	// destroy the object
 		}
@@ -496,7 +496,7 @@
 	{	// swap _Left and _Right basic_istringstreams
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Elem,
 	class _Traits,
 	class _Alloc> inline
@@ -516,7 +516,7 @@
 	typedef basic_istringstream<_Elem, _Traits> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 		// TEMPLATE CLASS basic_ostringstream
 template<class _Elem,
 	class _Traits,
@@ -543,7 +543,7 @@
 			_Stringbuffer(_Str, _Mode | ios_base::out)
 		{	// construct writable character buffer from NTCS
 		}
-
+/*
 	basic_ostringstream(_Myt&& _Right)
 		: _Mybase(&_Stringbuffer)
 		{	// construct by moving _Right
@@ -564,7 +564,7 @@
 			this->swap(_Right);
 			}
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// swap with _Right
 		if (this != &_Right)
@@ -573,12 +573,12 @@
 			_Stringbuffer.swap(_Right._Stringbuffer);
 			}
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// swap with _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	virtual ~basic_ostringstream()
 		{	// destroy the object
 		}
@@ -611,7 +611,7 @@
 	{	// swap _Left and _Right basic_ostringstreams
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Elem,
 	class _Traits,
 	class _Alloc> inline
@@ -631,7 +631,7 @@
 	typedef basic_ostringstream<_Elem, _Traits> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 		// TEMPLATE CLASS basic_stringstream
 template<class _Elem,
 	class _Traits,
@@ -664,7 +664,7 @@
 			_Stringbuffer(_Str, _Mode)
 		{	// construct character buffer from NTCS
 		}
-
+/*
 	basic_stringstream(_Myt&& _Right)
 		: _Mybase(&_Stringbuffer)
 		{	// construct by moving _Right
@@ -685,7 +685,7 @@
 			this->swap(_Right);
 			}
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// swap with _Right
 		if (this != &_Right)
@@ -694,12 +694,12 @@
 			_Stringbuffer.swap(_Right._Stringbuffer);
 			}
 		}
-
+/*
 	void swap(_Myt&& _Right)
 		{	// swap with _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	virtual ~basic_stringstream()
 		{	// destroy the object
 		}
@@ -732,7 +732,7 @@
 	{	// swap _Left and _Right basic_stringstreams
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Elem,
 	class _Traits,
 	class _Alloc> inline
@@ -751,7 +751,7 @@
 	{	// swap _Left and _Right basic_stringstreams
 	typedef basic_ostringstream<_Elem, _Traits> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
-	}
+	}*/
 _STD_END
  #pragma warning(pop)
  #pragma pack(pop)
Index: stack
===================================================================
--- stack	(revision 91)
+++ stack	(working copy)
@@ -41,7 +41,7 @@
 		c = _Right.c;
 		return (*this);
 		}
-
+/*
 	stack(_Myt&& _Right)
 		: c(_STD move(_Right.c))
 		{	// construct by moving _Right
@@ -73,7 +73,7 @@
 		{	// exchange contents with movable _Right
 		c.swap(_STD move(_Right.c));
 		}
-
+*/
 	bool empty() const
 		{	// test if stack is empty
 		return (c.empty());
@@ -126,7 +126,7 @@
 	{	// swap _Left and _Right stacks
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Ty,
 	class _Container> inline
 	void swap(stack<_Ty, _Container>& _Left,
@@ -144,7 +144,7 @@
 	typedef stack<_Ty, _Container> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 template<class _Ty,
 	class _Container> inline
 	bool operator==(const stack<_Ty, _Container>& _Left,
Index: stddef.h
===================================================================
--- stddef.h	(revision 91)
+++ stddef.h	(working copy)
@@ -52,6 +52,8 @@
 #endif
 
 /* Define offsetof macro */
+#define offsetof(s,m) ((size_t)__builtin_offsetof(s,m))
+#if 0 /* replaced for gccxml */
 #ifdef __cplusplus
 
 #ifdef  _WIN64
@@ -69,6 +71,7 @@
 #endif
 
 #endif	/* __cplusplus */
+#endif  /* 0 */
 
 _CRTIMP extern unsigned long  __cdecl __threadid(void);
 #define _threadid       (__threadid())
Index: stdio.h
===================================================================
--- stdio.h	(revision 91)
+++ stdio.h	(working copy)
@@ -531,7 +531,6 @@
 #ifndef _CRT_NON_CONFORMING_SWPRINTFS
 
 #define _SWPRINTFS_DEPRECATED _CRT_DEPRECATE_TEXT("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")
-
 #else
 
 #define _SWPRINTFS_DEPRECATED 
@@ -541,8 +540,8 @@
 /* we could end up with a double deprecation, disable warnings 4141 and 4996 */
 #pragma warning(push)
 #pragma warning(disable:4141 4996 4793)
-__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(int, __RETURN_POLICY_SAME, _SWPRINTFS_DEPRECATED _CRTIMP, _swprintf, _swprintf_s, _vswprintf, vswprintf_s, _Pre_notnull_ _Post_z_, wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format)
-__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(int, __RETURN_POLICY_SAME, _SWPRINTFS_DEPRECATED _CRTIMP, __swprintf_l, __vswprintf_l, _vswprintf_s_l, _Pre_notnull_ _Post_z_ wchar_t, , wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format, _locale_t, _Plocinfo)
+//__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(int, __RETURN_POLICY_SAME, _SWPRINTFS_DEPRECATED _CRTIMP, _swprintf, _swprintf_s, _vswprintf, vswprintf_s, _Pre_notnull_ _Post_z_, wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format)
+//__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(int, __RETURN_POLICY_SAME, _SWPRINTFS_DEPRECATED _CRTIMP, __swprintf_l, __vswprintf_l, _vswprintf_s_l, _Pre_notnull_ _Post_z_ wchar_t, , wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format, _locale_t, _Plocinfo)
 #pragma warning(pop)
 
 #if !defined(RC_INVOKED) && !defined(__midl)
Index: string
===================================================================
--- string	(revision 91)
+++ string	(working copy)
@@ -82,7 +82,7 @@
 	_Ans += _Right;
 	return (_Ans);
 	}
-
+/*
 template<class _Elem,
 	class _Traits,
 	class _Alloc> inline
@@ -156,7 +156,7 @@
 	{	// return string + character
 	return (_STD move(_Left.append(1, _Right)));
 	}
-
+*/
 template<class _Elem,
 	class _Traits,
 	class _Alloc> inline
@@ -336,7 +336,7 @@
 	{	// test if string >= NTCS
 	return (!(_Left < _Right));
 	}
-
+/*
 		// basic_string INSERTERS AND EXTRACTORS
 template<class _Elem,
 	class _Traits,
@@ -451,7 +451,7 @@
 	{	// get characters into string, discard newline
 	return (getline(_Istr, _Str, _Istr.widen('\n')));
 	}
-
+*/
 template<class _Elem,
 	class _Traits,
 	class _Alloc> inline
Index: strstream
===================================================================
--- strstream	(revision 91)
+++ strstream	(working copy)
@@ -70,7 +70,7 @@
 		}
 
   #pragma warning(pop)
-
+/*
 	__CLR_OR_THIS_CALL strstreambuf(_Myt&& _Right)
 		{	// construct by moving _Right
 		_Init();
@@ -91,7 +91,7 @@
 			this->swap(_Right);
 			}
 		}
-
+*/
 	void __CLR_OR_THIS_CALL swap(_Myt& _Right)
 		{	// swap with _Right
 		if (this != &_Right)
@@ -105,12 +105,12 @@
 			_STD swap(_Pfree, _Right._Pfree);
 			}
 		}
-
+/*
 	void __CLR_OR_THIS_CALL swap(_Myt&& _Right)
 		{	// swap with _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	virtual __CLR_OR_THIS_CALL ~strstreambuf()
 		{	// destroy a strstreambuf
 		_Tidy();
@@ -401,7 +401,7 @@
 	{	// swap _Left and _Right strstreambufs
 	_Left.swap(_Right);
 	}
-
+/*
 inline void swap(strstreambuf& _Left, strstreambuf&& _Right)
 	{	// swap _Left and _Right strstreambufs
 	typedef strstreambuf _Myt;
@@ -413,7 +413,7 @@
 	typedef strstreambuf _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 		// CLASS istrstream
 class istrstream
 	: public istream
@@ -444,7 +444,7 @@
 		: _Mybase(&_Strbuffer), _Strbuffer((const char *)_Ptr, _Count)
 		{	// construct with [_Ptr, _Ptr + _Count)
 		}
-
+/*
 	__CLR_OR_THIS_CALL istrstream(_Myt&& _Right)
 		: _Mybase(&_Strbuffer)
 		{	// construct by moving _Right
@@ -465,7 +465,7 @@
 			this->swap(_Right);
 			}
 		}
-
+*/
 	void __CLR_OR_THIS_CALL swap(_Myt& _Right)
 		{	// swap with _Right
 		if (this != &_Right)
@@ -474,12 +474,12 @@
 			_Strbuffer.swap(_Right._Strbuffer);
 			}
 		}
-
+/*
 	void __CLR_OR_THIS_CALL swap(_Myt&& _Right)
 		{	// swap with _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	virtual __CLR_OR_THIS_CALL ~istrstream()
 		{	// destroy an istrstream
 		}
@@ -503,7 +503,7 @@
 	{	// swap _Left and _Right istrstreams
 	_Left.swap(_Right);
 	}
-
+/*
 inline void swap(istrstream& _Left, istrstream&& _Right)
 	{	// swap _Left and _Right istrstreams
 	typedef istrstream _Myt;
@@ -515,7 +515,7 @@
 	typedef istrstream _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 		// CLASS ostrstream
 class ostrstream
 	: public ostream
@@ -540,7 +540,7 @@
 					? _Ptr : _Ptr + _CSTD strlen(_Ptr))
 		{	// construct with [_Ptr, _Ptr + _Count)
 		}
-
+/*
 	__CLR_OR_THIS_CALL ostrstream(_Myt&& _Right)
 		: _Mybase(&_Strbuffer)
 		{	// construct by moving _Right
@@ -561,7 +561,7 @@
 			this->swap(_Right);
 			}
 		}
-
+*/
 	void __CLR_OR_THIS_CALL swap(_Myt& _Right)
 		{	// swap with _Right
 		if (this != &_Right)
@@ -570,12 +570,12 @@
 			_Strbuffer.swap(_Right._Strbuffer);
 			}
 		}
-
+/*
 	void __CLR_OR_THIS_CALL swap(_Myt&& _Right)
 		{	// swap with _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	virtual __CLR_OR_THIS_CALL ~ostrstream()
 		{	// destroy an ostrstream
 		}
@@ -609,7 +609,7 @@
 	{	// swap _Left and _Right ostrstreams
 	_Left.swap(_Right);
 	}
-
+/*
 inline void swap(ostrstream& _Left, ostrstream&& _Right)
 	{	// swap _Left and _Right ostrstreams
 	typedef ostrstream _Myt;
@@ -621,7 +621,7 @@
 	typedef ostrstream _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 		// CLASS strstream
 class strstream
 	: public iostream
@@ -651,7 +651,7 @@
 					? _Ptr : _Ptr + _CSTD strlen(_Ptr))
 		{	// construct with [_Ptr, _Ptr + _Count)
 		}
-
+/*
 	__CLR_OR_THIS_CALL strstream(_Myt&& _Right)
 		: _Mybase(&_Strbuffer)
 		{	// construct by moving _Right
@@ -672,7 +672,7 @@
 			this->swap(_Right);
 			}
 		}
-
+*/
 	void __CLR_OR_THIS_CALL swap(_Myt& _Right)
 		{	// swap with _Right
 		if (this != &_Right)
@@ -681,12 +681,12 @@
 			_Strbuffer.swap(_Right._Strbuffer);
 			}
 		}
-
+/*
 	void __CLR_OR_THIS_CALL swap(_Myt&& _Right)
 		{	// swap with _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	virtual __CLR_OR_THIS_CALL ~strstream()
 		{	// destroy a strstream
 		}
@@ -720,7 +720,7 @@
 	{	// swap _Left and _Right strstreams
 	_Left.swap(_Right);
 	}
-
+/*
 inline void swap(strstream& _Left, strstream&& _Right)
 	{	// swap _Left and _Right strstreams
 	typedef strstream _Myt;
@@ -731,7 +731,7 @@
 	{	// swap _Left and _Right strstreams
 	typedef strstream _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
-	}
+	}*/
 _STD_END
 
  #pragma pop_macro("new")
Index: swprintf.inl
===================================================================
--- swprintf.inl	(revision 91)
+++ swprintf.inl	(working copy)
@@ -82,42 +82,22 @@
 
 #pragma warning( push )
 #pragma warning( disable : 4793 4141 )
-extern "C++" _SWPRINTFS_DEPRECATED _CRT_INSECURE_DEPRECATE(swprintf_s) __inline int swprintf(_Pre_notnull_ _Post_z_ wchar_t * _String, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...)
-{
-    va_list _Arglist;
-    _crt_va_start(_Arglist, _Format);
-    int _Ret = _vswprintf(_String, _Format, _Arglist);
-    _crt_va_end(_Arglist);
-    return _Ret;
-}
+extern "C++" int swprintf(_Pre_notnull_ _Post_z_ wchar_t * _String, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
 #pragma warning( pop )
 
 #pragma warning( push )
 #pragma warning( disable : 4141 )
-extern "C++" _SWPRINTFS_DEPRECATED _CRT_INSECURE_DEPRECATE(vswprintf_s) __inline int __CRTDECL vswprintf(_Pre_notnull_ _Post_z_ wchar_t * _String, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _Ap)
-{
-    return _vswprintf(_String, _Format, _Ap);
-}
+extern "C++" int __CRTDECL vswprintf(_Pre_notnull_ _Post_z_ wchar_t * _String, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _Ap);
 #pragma warning( pop )
 
 #pragma warning( push )
 #pragma warning( disable : 4793 4141 )
-extern "C++" _SWPRINTFS_DEPRECATED _CRT_INSECURE_DEPRECATE(_swprintf_s_l) __inline int _swprintf_l(_Pre_notnull_ _Post_z_ wchar_t * _String, _In_z_ _Printf_format_string_ const wchar_t * _Format, _locale_t _Plocinfo, ...)
-{
-    va_list _Arglist;
-    _crt_va_start(_Arglist, _Plocinfo);
-    int _Ret = __vswprintf_l(_String, _Format, _Plocinfo, _Arglist);
-    _crt_va_end(_Arglist);
-    return _Ret;
-}
+extern "C++" int _swprintf_l(_Pre_notnull_ _Post_z_ wchar_t * _String, _In_z_ _Printf_format_string_ const wchar_t * _Format, _locale_t _Plocinfo, ...);
 #pragma warning( pop )
 
 #pragma warning( push )
 #pragma warning( disable : 4141 )
-extern "C++" _SWPRINTFS_DEPRECATED _CRT_INSECURE_DEPRECATE(_vswprintf_s_l) __inline int __CRTDECL _vswprintf_l(_Pre_notnull_ _Post_z_ wchar_t * _String, _In_z_ _Printf_format_string_ const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
-{
-    return __vswprintf_l(_String, _Format, _Plocinfo, _Ap);
-}
+extern "C++" int __CRTDECL _vswprintf_l(_Pre_notnull_ _Post_z_ wchar_t * _String, _In_z_ _Printf_format_string_ const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap);
 #pragma warning( pop )
 
 #pragma warning( pop )
Index: type_traits
===================================================================
--- type_traits	(revision 91)
+++ type_traits	(working copy)
@@ -240,7 +240,8 @@
 template<class _Ty>
 	struct add_rvalue_reference
 	{	// add rvalue reference
-	typedef _Ty && type;
+//	typedef _Ty && type;
+	typedef _Ty & type;
 	};
 
 template<class _Ty>
@@ -422,13 +423,13 @@
 	: false_type
 	{	// determine whether _Ty is an rvalue reference
 	};
-
+/*
 template<class _Ty>
 	struct is_rvalue_reference<_Ty&&>
 	: true_type
 	{	// determine whether _Ty is an rvalue reference
 	};
-
+*/
 	// TEMPLATE CLASS is_reference
 template<class _Ty>
 	struct is_reference
@@ -500,13 +501,13 @@
 
 	// TEMPLATE CLASS is_union
 template<class _Ty>
-	struct is_union _IS_UNION(_Ty)
+	struct is_union// _IS_UNION(_Ty)
 	{	// determine whether _Ty is a union
 	};
 
 	// TEMPLATE CLASS is_class
 template<class _Ty>
-	struct is_class _IS_CLASS(_Ty)
+	struct is_class// _IS_CLASS(_Ty)
 	{	// determine whether _Ty is a class
 	};
 
@@ -551,14 +552,14 @@
 	// TEMPLATE CLASS is_convertible
 
 template<class _From, class _To>
-	struct is_convertible _IS_CONVERTIBLE(_From, _To)
+	struct is_convertible// _IS_CONVERTIBLE(_From, _To)
 	{	// determine whether _From is convertible to _To
 	};
 
 	// TEMPLATE CLASS is_enum
 
 template<class _Ty>
-	struct is_enum _IS_ENUM(_Ty)
+	struct is_enum// _IS_ENUM(_Ty)
 	{	// determine whether _Ty is an enumerated type
 	};
 
@@ -635,7 +636,7 @@
 
 	// TEMPLATE CLASS is_pod
 template<class _Ty>
-	struct _Is_pod _IS_POD(_Ty)
+	struct _Is_pod// _IS_POD(_Ty)
 	{	// determine whether _Ty is a POD type
 	};
 
@@ -647,19 +648,19 @@
 
 	// TEMPLATE CLASS is_empty
 template<class _Ty>
-	struct is_empty _IS_EMPTY(_Ty)
+	struct is_empty// _IS_EMPTY(_Ty)
 	{	// determine whether _Ty is an empty class
 	};
 
 	// TEMPLATE CLASS is_polymorphic
 template<class _Ty>
-	struct is_polymorphic _IS_POLYMORPHIC(_Ty)
+	struct is_polymorphic// _IS_POLYMORPHIC(_Ty)
 	{	// determine whether _Ty is a polymorphic type
 	};
 
 	// TEMPLATE CLASS is_abstract
 template<class _Ty>
-	struct is_abstract _IS_ABSTRACT(_Ty)
+	struct is_abstract// _IS_ABSTRACT(_Ty)
 	{	// determine whether _Ty is an abstract class
 	};
 
@@ -679,77 +680,77 @@
 
 	// TEMPLATE CLASS has_trivial_constructor -- retained
 template<class _Ty>
-	struct has_trivial_constructor _HAS_TRIVIAL_CONSTRUCTOR(_Ty)
+	struct has_trivial_constructor// _HAS_TRIVIAL_CONSTRUCTOR(_Ty)
 	{	// determine whether _Ty has a trivial constructor
 	};
 
 	// TEMPLATE CLASS has_trivial_copy -- retained
 template<class _Ty>
-	struct has_trivial_copy _HAS_TRIVIAL_COPY(_Ty)
+	struct has_trivial_copy// _HAS_TRIVIAL_COPY(_Ty)
 	{	// determine whether _Ty has a trivial copy constructor
 	};
 
  #if _HAS_CPP0X
 	// TEMPLATE CLASS has_trivial_default_constructor
 template<class _Ty>
-	struct has_trivial_default_constructor _HAS_TRIVIAL_CONSTRUCTOR(_Ty)
+	struct has_trivial_default_constructor// _HAS_TRIVIAL_CONSTRUCTOR(_Ty)
 	{	// determine whether _Ty has a trivial constructor
 	};
 
 	// TEMPLATE CLASS has_trivial_copy_constructor
 template<class _Ty>
-	struct has_trivial_copy_constructor _HAS_TRIVIAL_COPY(_Ty)
+	struct has_trivial_copy_constructor// _HAS_TRIVIAL_COPY(_Ty)
 	{	// determine whether _Ty has a trivial copy constructor
 	};
  #endif /* _HAS_CPP0X */
 
 	// TEMPLATE CLASS has_trivial_assign
 template<class _Ty>
-	struct has_trivial_assign _HAS_TRIVIAL_ASSIGN(_Ty)
+	struct has_trivial_assign// _HAS_TRIVIAL_ASSIGN(_Ty)
 	{	// determine whether _Ty has a trivial assignment operator
 	};
 
 	// TEMPLATE CLASS has_trivial_destructor
 template<class _Ty>
-	struct has_trivial_destructor _HAS_TRIVIAL_DESTRUCTOR(_Ty)
+	struct has_trivial_destructor// _HAS_TRIVIAL_DESTRUCTOR(_Ty)
 	{	// determine whether _Ty has a trivial destructor
 	};
 
 	// TEMPLATE CLASS has_nothrow_constructor -- retained
 template<class _Ty>
-	struct has_nothrow_constructor _HAS_NOTHROW_CONSTRUCTOR(_Ty)
+	struct has_nothrow_constructor// _HAS_NOTHROW_CONSTRUCTOR(_Ty)
 	{	// determine whether _Ty has a nothrow constructor
 	};
 
 	// TEMPLATE CLASS has_nothrow_copy -- retained
 template<class _Ty>
-	struct has_nothrow_copy _HAS_NOTHROW_COPY(_Ty)
+	struct has_nothrow_copy// _HAS_NOTHROW_COPY(_Ty)
 	{	// determine whether _Ty has a nothrow copy constructor
 	};
 
  #if _HAS_CPP0X
 	// TEMPLATE CLASS has_nothrow_default_constructor
 template<class _Ty>
-	struct has_nothrow_default_constructor _HAS_NOTHROW_CONSTRUCTOR(_Ty)
+	struct has_nothrow_default_constructor// _HAS_NOTHROW_CONSTRUCTOR(_Ty)
 	{	// determine whether _Ty has a nothrow constructor
 	};
 
 	// TEMPLATE CLASS has_nothrow_copy_constructor
 template<class _Ty>
-	struct has_nothrow_copy_constructor _HAS_NOTHROW_COPY(_Ty)
+	struct has_nothrow_copy_constructor// _HAS_NOTHROW_COPY(_Ty)
 	{	// determine whether _Ty has a nothrow copy constructor
 	};
  #endif /* _HAS_CPP0X */
 
 	// TEMPLATE CLASS has_nothrow_assign
 template<class _Ty>
-	struct has_nothrow_assign _HAS_NOTHROW_ASSIGN(_Ty)
+	struct has_nothrow_assign// _HAS_NOTHROW_ASSIGN(_Ty)
 	{	// determine whether _Ty has a nothrow assignment operator
 	};
 
 	// TEMPLATE CLASS has_virtual_destructor
 template<class _Ty>
-	struct has_virtual_destructor _HAS_VIRTUAL_DESTRUCTOR(_Ty)
+	struct has_virtual_destructor// _HAS_VIRTUAL_DESTRUCTOR(_Ty)
 	{	// determine whether _Ty has a virtaul destructor
 	};
 
@@ -950,7 +951,7 @@
 
 	// TEMPLATE CLASS is_base_of
 template<class _Base, class _Der>
-	struct is_base_of _IS_BASE_OF(_Base, _Der)
+	struct is_base_of// _IS_BASE_OF(_Base, _Der)
 	{	// determine whether _Base is a base of or the same as _Der
 	};
 
Index: typeinfo
===================================================================
--- typeinfo	(revision 91)
+++ typeinfo	(working copy)
@@ -40,6 +40,7 @@
 
 extern __type_info_node __type_info_root_node;
 
+namespace std {
 class type_info {
 public:
  #if _HAS_CPP0X
@@ -74,6 +75,8 @@
     _CRTIMP_PURE static const char *__CLRCALL_OR_CDECL _Name_base(const type_info *,__type_info_node* __ptype_info_node);
     _CRTIMP_PURE static void __CLRCALL_OR_CDECL _Type_info_dtor(type_info *);
 };
+}
+using std::type_info;
 
  #if _HAS_EXCEPTIONS
 
Index: utility
===================================================================
--- utility	(revision 91)
+++ utility	(working copy)
@@ -71,7 +71,7 @@
 		return (_Left);
 		}
 	};
-
+/*
 	// TEMPLATE FUNCTION forward
 template<class _Ty> inline
 	_Ty&& forward(typename identity<_Ty>::type& _Arg)
@@ -94,14 +94,14 @@
 	{	// forward _Arg as movable
 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
 	}
-
+*/
 		// TEMPLATE FUNCTION swap (from <algorithm>)
 template<class _Ty> inline
 	void swap(_Ty& _Left, _Ty& _Right)
 	{	// exchange values stored at _Left and _Right
-	_Ty _Tmp = _Move(_Left);
-	_Left = _Move(_Right);
-	_Right = _Move(_Tmp);
+//	_Ty _Tmp = _Move(_Left);
+//	_Left = _Move(_Right);
+//	_Right = _Move(_Tmp);
 	}
 
 		// TEMPLATE FUNCTION _Swap_adl
@@ -138,7 +138,7 @@
 
 	typedef typename tr1::remove_reference<_Ty1>::type _Ty1x;
 	typedef typename tr1::remove_reference<_Ty2>::type _Ty2x;
-
+/*
 	_Pair_base(_Ty1x&& _Val1, _Ty2x&& _Val2)
 		: first(_STD move(_Val1)),
 			second(_STD move(_Val2))
@@ -162,7 +162,7 @@
 			second(_STD forward<_Other2>(_Val2))
 		{	// construct from moved values
 		}
-
+*/
 	_Ty1 first;	// the first stored value
 	_Ty2 second;	// the second stored value
 	};
@@ -220,7 +220,7 @@
 
 	typedef typename tr1::remove_reference<_Ty1>::type _Ty1x;
 	typedef typename tr1::remove_reference<_Ty2>::type _Ty2x;
-
+/*
 	pair(_Ty1x&& _Val1, _Ty2x&& _Val2)
 		: _Mybase(_STD move(_Val1),
 			_STD move(_Val2))
@@ -269,7 +269,7 @@
 			this->first = _STD move(_Right.first);
 			this->second = _STD move(_Right.second);
 			}
-		}
+		}*/
 	};
 
 		// pair TEMPLATE FUNCTIONS
@@ -280,7 +280,7 @@
 	{	// swap _Left and _Right pairs
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Ty1,
 	class _Ty2> inline
 	void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>&& _Right)
@@ -296,7 +296,7 @@
 	typedef pair<_Ty1, _Ty2> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 template<class _Ty1,
 	class _Ty2> inline
 	bool operator==(const pair<_Ty1, _Ty2>& _Left,
@@ -347,7 +347,7 @@
 	}
 
 	// TEMPLATE FUNCTION make_pair
-
+/*
 template<class _Ty1,
 	class _Ty2> inline
 	pair<typename _Unrefwrap<_Ty1>::type,
@@ -383,7 +383,7 @@
 	return (_Mypair(_STD forward<_Ty1>(_Val1),
 		(typename _Unrefwrap<_Ty2>::type)_Val2));
 	}
-
+*/
 template<class _Ty1,
 	class _Ty2> inline
 	pair<typename _Unrefwrap<_Ty1>::type,
Index: valarray
===================================================================
--- valarray	(revision 91)
+++ valarray	(working copy)
@@ -101,7 +101,7 @@
 		_Tidy();
 		*this = _Indarr;
 		}
-
+/*
 	valarray(_Myt&& _Right)
 		{	// construct by moving _Right
 		_Tidy();
@@ -129,7 +129,7 @@
 		{	// exchange contents with movable _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	void swap(_Myt& _Right)
 		{	// exchange contents with _Right
 		if (this != &_Right)
@@ -444,8 +444,8 @@
 			_Myptr = _Allocate(_Newsize, (_Ty *)0);
 
 			_TRY_BEGIN
-			for (size_t _Idx = 0; _Idx < _Newsize; ++_Idx, _Ptr += _Inc)
-				_Construct(&_Myptr[_Idx], *_Ptr);
+			//for (size_t _Idx = 0; _Idx < _Newsize; ++_Idx, _Ptr += _Inc)
+			//	_Construct(&_Myptr[_Idx], *_Ptr);
 			_CATCH_ALL
 			_Tidy(true);	// construction failed, clean up and reraise
 			_RERAISE;
@@ -479,7 +479,7 @@
 	{	// swap _Left and _Right valarrays
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Ty> inline
 	void swap(valarray<_Ty>& _Left,
 		valarray<_Ty>&& _Right)
@@ -495,7 +495,7 @@
 	typedef valarray<_Ty> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
  #if _HAS_CPP0X
 template<class _Ty> inline
 	_Ty *begin(valarray<_Ty>& _Array)
Index: vector
===================================================================
--- vector	(revision 91)
+++ vector	(working copy)
@@ -589,7 +589,7 @@
 			_CATCH_END
 			}
 		}
-
+/*
 	vector(_Myt&& _Right)
 		: _Mybase(_Right._Alval)
 		{	// construct by moving _Right
@@ -683,7 +683,7 @@
  #if _ITERATOR_DEBUG_LEVEL == 2
 		if (size() < _Off)
 			_DEBUG_ERROR("vector emplace iterator outside range");
- #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
+ #endif /* _ITERATOR_DEBUG_LEVEL == 2 * /
 
 		emplace_back(_STD forward<_Valty>(_Val));
 		_STD rotate(begin() + _Off, end() - 1, end());
@@ -699,7 +699,7 @@
 			_Assign_rv(_STD forward<_Myt>(_Right));
 			}
 		}
-
+*/
 	~vector()
 		{	// destroy the object
 		_Tidy();
@@ -1463,7 +1463,7 @@
 	{	// swap _Left and _Right vectors
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Ty,
 	class _Alloc> inline
 	void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>&& _Right)
@@ -1479,7 +1479,7 @@
 	typedef vector<_Ty, _Alloc> _Myt;
 	_Right.swap(_STD forward<_Myt>(_Left));
 	}
-
+*/
 template<class _Ty,
 	class _Alloc> inline
 	bool operator==(const vector<_Ty, _Alloc>& _Left,
@@ -2146,7 +2146,7 @@
 		{	// initialize from [_First, _Last), input iterators
 		insert(begin(), _First, _Last);
 		}
-
+/*
 	vector(_Myt&& _Right)
 		: _Mybase(0, false, _Right.get_allocator())
 		{	// construct by moving _Right
@@ -2179,7 +2179,7 @@
 		{	// exchange contents with movable _Right
 		_Assign_rv(_STD move(_Right));
 		}
-
+*/
 	~vector()
 		{	// destroy the object
 		this->_Mysize = 0;
Index: wchar.h
===================================================================
--- wchar.h	(revision 91)
+++ wchar.h	(working copy)
@@ -758,8 +758,8 @@
 /* we could end up with a double deprecation, disable warnings 4141 and 4996 */
 #pragma warning(push)
 #pragma warning(disable:4141 4996)
-__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(int, __RETURN_POLICY_SAME, _SWPRINTFS_DEPRECATED _CRTIMP, _swprintf, _swprintf_s, _vswprintf, vswprintf_s, _Pre_notnull_ _Post_z_, wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format)
-__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(int, __RETURN_POLICY_SAME, _SWPRINTFS_DEPRECATED _CRTIMP, __swprintf_l, __vswprintf_l, _vswprintf_s_l, _Pre_notnull_ _Post_z_ wchar_t, _Out_, wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format, _locale_t, _Plocinfo)
+//__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(int, __RETURN_POLICY_SAME, _SWPRINTFS_DEPRECATED _CRTIMP, _swprintf, _swprintf_s, _vswprintf, vswprintf_s, _Pre_notnull_ _Post_z_, wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format)
+//__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(int, __RETURN_POLICY_SAME, _SWPRINTFS_DEPRECATED _CRTIMP, __swprintf_l, __vswprintf_l, _vswprintf_s_l, _Pre_notnull_ _Post_z_ wchar_t, _Out_, wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format, _locale_t, _Plocinfo)
 #pragma warning(pop)
 
 #if !defined(RC_INVOKED) && !defined(__midl)
Index: xdebug
===================================================================
--- xdebug	(revision 91)
+++ xdebug	(working copy)
@@ -56,7 +56,9 @@
 	{	// delete from the debug CRT heap even if operator delete exists
 	if (_Ptr != 0)
 		{	// worth deleting
+#if 0
 		_Ptr->~_Ty();
+#endif
 		// delete as _NORMAL_BLOCK, not _CRT_BLOCK, since we might have
 		// facets allocated by normal new.
 		free(_Ptr);
Index: xhash
===================================================================
--- xhash	(revision 91)
+++ xhash	(working copy)
@@ -241,7 +241,7 @@
 		{	// construct hash table by copying right
 		_Copy(_Right);
 		}
-
+/*
 	_Hash(_Myt&& _Right)
 		: _Traits(_Right.comp),
 			_List(_Right.get_allocator()),
@@ -310,7 +310,7 @@
 		{	// exchange contents with movable _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	~_Hash()
 		{	// destroy hash table
 		}
Index: xlocale
===================================================================
--- xlocale	(revision 91)
+++ xlocale	(working copy)
@@ -55,6 +55,8 @@
 class locale;
 template<class _Facet>
 	const _Facet& __CRTDECL use_facet(const locale&);
+template<class _Elem>
+     class collate;
 
 class  locale
 	: public _Locbase<int>
Index: xlocnum
===================================================================
--- xlocnum	(revision 91)
+++ xlocnum	(working copy)
@@ -1493,7 +1493,7 @@
 				{	// add a NUL to mark thousands separator
 				_Off -= *_Pg;
 
-				__analysis_assume(_Count + 1 > _Off);
+				//__analysis_assume(_Count + 1 > _Off);
 				_CRT_SECURE_MEMMOVE(&_Buf[_Off + 1], _Count + 1 - _Off,
 					&_Buf[_Off], _Count + 1 - _Off);
 
Index: xmemory
===================================================================
--- xmemory	(revision 91)
+++ xmemory	(working copy)
@@ -38,7 +38,7 @@
 
 	return ((_Ty _FARQ *)_Ptr);
 	}
-
+/*
 		// TEMPLATE FUNCTION _Construct
 template<class _Ty1,
 	class _Ty2> inline
@@ -47,7 +47,7 @@
 	void _FARQ *_Vptr = _Ptr;
 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
 	}
-
+*/
 template<class _Ty1> inline
 	void _Construct(_Ty1 _FARQ *_Ptr)
 	{	// construct object at _Ptr with default value
@@ -196,7 +196,7 @@
 		{	// construct object at _Ptr with value _Val
 		_Construct(_Ptr, _Val);
 		}
-
+/*
 	void construct(pointer _Ptr, _Ty&& _Val)
 		{	// construct object at _Ptr with value _Val
 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));
@@ -207,7 +207,7 @@
 		{	// construct object at _Ptr with value _Val
 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));
 		}
-
+*/
 	void destroy(pointer _Ptr)
 		{	// destroy object at _Ptr
 		_Destroy(_Ptr);
@@ -270,7 +270,7 @@
 	{	// test for allocator inequality
 	return (!(_Left == _Right));
 	}
-
+/*
 		// TEMPLATE FUNCTIONS _Cons_val AND _Dest_val
 template<class _Alloc,
 	class _Ty1,
@@ -279,7 +279,7 @@
 	{	// construct using allocator
 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));
 	}
-
+*/
 template<class _Alloc,
 	class _Ty1>
 	void _Dest_val(_Alloc& _Alval, _Ty1 *_Pdest)
Index: xstddef
===================================================================
--- xstddef	(revision 91)
+++ xstddef	(working copy)
@@ -34,7 +34,7 @@
  #endif /* _THROWS */
 
   #define _THROW0()		throw ()
-  #define _THROW1(x)	throw (...)
+  #define _THROW1(x)	throw (x)
 
    #define _THROW(x, y)			throw x(y)
    #define _THROW_NCEE(x, y)	throw x(y)
Index: xstring
===================================================================
--- xstring	(revision 91)
+++ xstring	(working copy)
@@ -696,7 +696,7 @@
 		if (_First != _Last)
 			assign(&*_First, _Last - _First);
 		}
-
+/*
 	basic_string(_Myt&& _Right)
 		: _Mybase(_STD forward<_Alloc>(_Right._Alval))
 		{	// construct by moving _Right
@@ -743,12 +743,12 @@
  #if 0 < _ITERATOR_DEBUG_LEVEL
 			this->_Orphan_all();
 			this->_Swap_all(_Right);
- #endif /* 0 < _ITERATOR_DEBUG_LEVEL */
+ #endif /* 0 < _ITERATOR_DEBUG_LEVEL * /
 
 			assign(_STD forward<_Myt>(_Right));
 			}
 		}
-
+*/
 	~basic_string()
 		{	// destroy the string
 		_Tidy(true);
@@ -2040,7 +2040,7 @@
 	{	// swap _Left and _Right strings
 	_Left.swap(_Right);
 	}
-
+/*
 template<class _Elem,
 	class _Traits,
 	class _Alloc> inline
@@ -2058,7 +2058,7 @@
 	{	// swap _Left and _Right strings
 	_Right.swap(_Left);
 	}
-
+*/
 typedef basic_string<char, char_traits<char>, allocator<char> >
 	string;
 typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
Index: xtr1common
===================================================================
--- xtr1common	(revision 91)
+++ xtr1common	(working copy)
@@ -350,26 +350,26 @@
 	{	// remove reference
 	typedef _Ty _Type;
 	};
-
+/*
 template<class _Ty>
 	struct _Remove_reference<_Ty&&>
 	{	// remove rvalue reference
 	typedef _Ty _Type;
 	};
-
+*/
 	// TEMPLATE _Remove_rvalue_reference
 template<class _Ty>
 	struct _Remove_rvalue_reference
 	{	// remove rvalue reference
 	typedef _Ty _Type;
 	};
-
+/*
 template<class _Ty>
 	struct _Remove_rvalue_reference<_Ty&&>
 	{	// remove rvalue reference
 	typedef _Ty _Type;
 	};
-
+*/
 	// TEMPLATE STRUCT _Copy_cv
 template<class _Tgt,
 	class _Src>
Index: xtree
===================================================================
--- xtree	(revision 91)
+++ xtree	(working copy)
@@ -581,7 +581,7 @@
 
 		return (_Wherenode);
 		}
-
+/*
 	template<class _Valty>
 		_Nodeptr _Buynode(_Valty&& _Val)
 		{	// allocate a node with defaults
@@ -597,7 +597,7 @@
 
 		return (_Wherenode);
 		}
-
+*/
 	enum _Redbl
 		{	// colors for link to parent
 		_Red, _Black};
@@ -720,7 +720,7 @@
 		_RERAISE;
 		_CATCH_END
 		}
-
+/*
 	_Tree(_Myt&& _Right)
 		: _Mybase(_Right.key_comp(), _Right._Alval)
 		{	// construct tree by copying _Right
@@ -785,7 +785,7 @@
 		{	// exchange contents with movable _Right
 		_Assign_rv(_STD forward<_Myt>(_Right));
 		}
-
+*/
 	~_Tree()
 		{	// destroy tree
 		_Tidy();
Index: xutility
===================================================================
--- xutility	(revision 91)
+++ xutility	(working copy)
@@ -2503,7 +2503,7 @@
 		_Dest, _Is_checked(_Dest)));
 	}
  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
-
+/*
 		// TEMPLATE FUNCTION move
 template<class _InIt,
 	class _OutIt> inline
@@ -2514,7 +2514,7 @@
 		*_Dest = _STD move(*_First);
 	return (_Dest);
 	}
-
+*/
 template<class _InIt,
 	class _OutIt> inline
 	_OutIt _Move(_InIt _First, _InIt _Last,
Index: xxmem_fn
===================================================================
--- xxmem_fn	(revision 91)
+++ xxmem_fn	(working copy)
@@ -28,13 +28,14 @@
 	// TEMPLATE FUNCTION mem_fn, pointer to member function
 template<class _Rx,
 	_CLASS_ARG0>
-	_NAME<_Rx, _Rx(__thiscall _Arg0::*)(_ARG1_ARG2), _ARG0_ARG1>
-		mem_fn(_Rx(__thiscall _Arg0::*_Pm)(_ARG1_ARG2))
+	_NAME<_Rx, _Rx(_Arg0::*)(_ARG1_ARG2), _ARG0_ARG1>
+		mem_fn(_Rx(_Arg0::*_Pm)(_ARG1_ARG2))
 	{	// bind to pointer to member function
-	return (_NAME<_Rx, _Rx(__thiscall _Arg0::*)(_ARG1_ARG2),
+	return (_NAME<_Rx, _Rx(_Arg0::*)(_ARG1_ARG2),
 		_ARG0_ARG1>(_Pm));
 	}
 
+#if 0 // Disabled for gccxml
  #ifdef _M_IX86
 template<class _Rx,
 	_CLASS_ARG0>
@@ -77,18 +78,20 @@
 		_ARG0_ARG1>(_Pm));
 	}
  #endif /* _M_CEE */
+#endif // Disabled for gccxml
 
 	// TEMPLATE FUNCTION mem_fn, pointer to const member function
 template<class _Rx,
 	_CLASS_ARG0>
-	_NAME<_Rx, _Rx(__thiscall _Arg0::*)(_ARG1_ARG2) const,
+	_NAME<_Rx, _Rx(_Arg0::*)(_ARG1_ARG2) const,
 		const _ARG0_ARG1>
-		mem_fn(_Rx(__thiscall _Arg0::*_Pm)(_ARG1_ARG2) const)
+		mem_fn(_Rx(_Arg0::*_Pm)(_ARG1_ARG2) const)
 	{	// bind to pointer to const member function
-	return (_NAME<_Rx, _Rx(__thiscall _Arg0::*)(_ARG1_ARG2) const,
+	return (_NAME<_Rx, _Rx(_Arg0::*)(_ARG1_ARG2) const,
 		const _ARG0_ARG1>(_Pm));
 	}
 
+#if 0 // Disabled for gccxml
  #ifdef _M_IX86
 template<class _Rx,
 	_CLASS_ARG0>
@@ -135,18 +138,20 @@
 		const _ARG0_ARG1>(_Pm));
 	}
  #endif /* _M_CEE */
+#endif // Disabled for gccxml
 
 	// TEMPLATE FUNCTION mem_fn, pointer to volatile member function
 template<class _Rx,
 	_CLASS_ARG0>
-	_NAME<_Rx, _Rx(__thiscall _Arg0::*)(_ARG1_ARG2) volatile,
+	_NAME<_Rx, _Rx(_Arg0::*)(_ARG1_ARG2) volatile,
 		volatile _ARG0_ARG1>
-		mem_fn(_Rx(__thiscall _Arg0::*_Pm)(_ARG1_ARG2) volatile)
+		mem_fn(_Rx(_Arg0::*_Pm)(_ARG1_ARG2) volatile)
 	{	// bind to pointer to volatile member function
-	return (_NAME<_Rx, _Rx(__thiscall _Arg0::*)(_ARG1_ARG2) volatile,
+	return (_NAME<_Rx, _Rx(_Arg0::*)(_ARG1_ARG2) volatile,
 		volatile _ARG0_ARG1>(_Pm));
 	}
 
+#if 0 // Disabled for gccxml
  #ifdef _M_IX86
 template<class _Rx,
 	_CLASS_ARG0>
@@ -193,18 +198,20 @@
 		volatile _ARG0_ARG1>(_Pm));
 	}
  #endif /* _M_CEE */
+#endif // Disabled for gccxml
 
 	// TEMPLATE FUNCTION mem_fn, pointer to const volatile member function
 template<class _Rx,
 	_CLASS_ARG0>
-	_NAME<_Rx, _Rx(__thiscall _Arg0::*)(_ARG1_ARG2) const volatile,
+	_NAME<_Rx, _Rx(_Arg0::*)(_ARG1_ARG2) const volatile,
 		const volatile _ARG0_ARG1>
-		mem_fn(_Rx(__thiscall _Arg0::*_Pm)(_ARG1_ARG2) const volatile)
+		mem_fn(_Rx(_Arg0::*_Pm)(_ARG1_ARG2) const volatile)
 	{	// bind to pointer to const volatile member function
-	return (_NAME<_Rx, _Rx(__thiscall _Arg0::*)(_ARG1_ARG2) const volatile,
+	return (_NAME<_Rx, _Rx(_Arg0::*)(_ARG1_ARG2) const volatile,
 		const volatile _ARG0_ARG1>(_Pm));
 	}
 
+#if 0 // Disabled for gccxml
  #ifdef _M_IX86
 template<class _Rx,
 	_CLASS_ARG0>
@@ -251,6 +258,7 @@
 		const volatile _ARG0_ARG1>(_Pm));
 	}
  #endif /* _M_CEE */
+#endif // Disabled for gccxml
 
 #undef _NAME
 
Index: xxresult
===================================================================
--- xxresult	(revision 91)
+++ xxresult	(working copy)
@@ -167,12 +167,13 @@
 template<class _Rx,
 	_CLASS_ARG0
 	_C_CLASS_FARG0>
-	struct _RESULT_OF<_Rx (__thiscall _Arg0::*)(_ARG1_ARG2),
+	struct _RESULT_OF<_Rx (_Arg0::*)(_ARG1_ARG2),
 		_Farg0& _C_FARG1_FARG2>
 	{	// pointer to member fn
 	typedef _Rx _Type;
 	};
-
+#endif
+#if 0 // Disabled for gccxml
  #ifdef _M_IX86
 template<class _Rx,
 	_CLASS_ARG0
@@ -215,17 +216,19 @@
 	typedef _Rx _Type;
 	};
  #endif /* _M_CEE */
+#endif // Disabled for gccxml
 
 	// TEMPLATE FUNCTION _RESULT_OF, pointer to const member fn
 template<class _Rx,
 	_CLASS_ARG0
 	_C_CLASS_FARG0>
-	struct _RESULT_OF<_Rx (__thiscall _Arg0::*)(_ARG1_ARG2) const,
+	struct _RESULT_OF<_Rx (_Arg0::*)(_ARG1_ARG2) const,
 		_Farg0& _C_FARG1_FARG2>
 	{	// pointer to const member fn
 	typedef _Rx _Type;
 	};
 
+#if 0 // Disabled for gccxml
  #ifdef _M_IX86
 template<class _Rx,
 	_CLASS_ARG0
@@ -268,17 +271,19 @@
 	typedef _Rx _Type;
 	};
  #endif /* _M_CEE */
+#endif // Disabled for gccxml
 
 	// TEMPLATE FUNCTION _RESULT_OF, pointer to volatile member fn
 template<class _Rx,
 	_CLASS_ARG0
 	_C_CLASS_FARG0>
-	struct _RESULT_OF<_Rx (__thiscall _Arg0::*)(_ARG1_ARG2) volatile,
+	struct _RESULT_OF<_Rx (_Arg0::*)(_ARG1_ARG2) volatile,
 		_Farg0& _C_FARG1_FARG2>
 	{	// pointer to volatile member fn
 	typedef _Rx _Type;
 	};
 
+#if 0 // Disabled for gccxml
  #ifdef _M_IX86
 template<class _Rx,
 	_CLASS_ARG0
@@ -321,17 +326,19 @@
 	typedef _Rx _Type;
 	};
  #endif /* _M_CEE */
+#endif // Disabled for gccxml
 
 	// TEMPLATE FUNCTION _RESULT_OF, pointer to const volatile member fn
 template<class _Rx,
 	_CLASS_ARG0
 	_C_CLASS_FARG0>
-	struct _RESULT_OF<_Rx (__thiscall _Arg0::*)(_ARG1_ARG2) const volatile,
+	struct _RESULT_OF<_Rx (_Arg0::*)(_ARG1_ARG2) const volatile,
 		_Farg0& _C_FARG1_FARG2>
 	{	// pointer to const volatile member fn
 	typedef _Rx _Type;
 	};
 
+#if 0 // Disabled for gccxml
  #ifdef _M_IX86
 template<class _Rx,
 	_CLASS_ARG0
@@ -374,17 +381,19 @@
 	typedef _Rx _Type;
 	};
  #endif /* _M_CEE */
+#endif // Disabled for gccxml
 
 	// TEMPLATE FUNCTION _RESULT_OF, const pointer to member fn
 template<class _Rx,
 	_CLASS_ARG0
 	_C_CLASS_FARG0>
-	struct _RESULT_OF<_Rx (__thiscall _Arg0::*const)(_ARG1_ARG2),
+	struct _RESULT_OF<_Rx (_Arg0::*const)(_ARG1_ARG2),
 		_Farg0& _C_FARG1_FARG2>
 	{	// const pointer to member fn
 	typedef _Rx _Type;
 	};
 
+#if 0 // Disabled for gccxml
  #ifdef _M_IX86
 template<class _Rx,
 	_CLASS_ARG0
@@ -427,17 +436,19 @@
 	typedef _Rx _Type;
 	};
  #endif /* _M_CEE */
+#endif // Disabled for gccxml
 
 	// TEMPLATE FUNCTION _RESULT_OF, const pointer to const member fn
 template<class _Rx,
 	_CLASS_ARG0
 	_C_CLASS_FARG0>
-	struct _RESULT_OF<_Rx (__thiscall _Arg0::*const)(_ARG1_ARG2) const,
+	struct _RESULT_OF<_Rx (_Arg0::*const)(_ARG1_ARG2) const,
 		_Farg0& _C_FARG1_FARG2>
 	{	// const pointer to const member fn
 	typedef _Rx _Type;
 	};
 
+#if 0 // Disabled for gccxml
  #ifdef _M_IX86
 template<class _Rx,
 	_CLASS_ARG0
@@ -480,17 +491,19 @@
 	typedef _Rx _Type;
 	};
  #endif /* _M_CEE */
+#endif // Disabled for gccxml
 
 	// TEMPLATE FUNCTION _RESULT_OF, const pointer to volatile member fn
 template<class _Rx,
 	_CLASS_ARG0
 	_C_CLASS_FARG0>
-	struct _RESULT_OF<_Rx (__thiscall _Arg0::*const)(_ARG1_ARG2) volatile,
+	struct _RESULT_OF<_Rx (_Arg0::*const)(_ARG1_ARG2) volatile,
 		_Farg0& _C_FARG1_FARG2>
 	{	// const pointer to volatile member fn
 	typedef _Rx _Type;
 	};
 
+#if 0 // Disabled for gccxml
  #ifdef _M_IX86
 template<class _Rx,
 	_CLASS_ARG0
@@ -533,17 +546,19 @@
 	typedef _Rx _Type;
 	};
  #endif /* _M_CEE */
+#endif // Disabled for gccxml
 
 	// TEMPLATE FUNCTION _RESULT_OF, const pointer to const volatile member fn
 template<class _Rx,
 	_CLASS_ARG0
 	_C_CLASS_FARG0>
-	struct _RESULT_OF<_Rx (__thiscall _Arg0::*const)(_ARG1_ARG2) const volatile,
+	struct _RESULT_OF<_Rx (_Arg0::*const)(_ARG1_ARG2) const volatile,
 		_Farg0& _C_FARG1_FARG2>
 	{	// const pointer to const volatile member fn
 	typedef _Rx _Type;
 	};
 
+#if 0 // Disabled for gccxml
  #ifdef _M_IX86
 template<class _Rx,
 	_CLASS_ARG0
Index: xxshared
===================================================================
--- xxshared	(revision 91)
+++ xxshared	(working copy)
@@ -1,6 +1,9 @@
 // xxshared internal header
 // NOTE: no include guard
 
+#define __GCCXML_WTF
+#ifndef __GCCXML_WTF
+
  #ifdef _REF_COUNT_OBJ_CTOR
 
  #if _NARGS != 0
@@ -11,7 +14,7 @@
 		: _Ref_count_base()
 		{	// construct
 		new ((void *) &_Storage) _Ty(_A0_A1_FWD);
-		}
+		}*/
  #endif /* _REF_COUNT_OBJ_CTOR */
 
  #ifdef _REF_COUNT_OBJ_ALLOC_CTOR
@@ -67,3 +70,5 @@
  * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.
  * Consult your license regarding permissions and restrictions.
 V5.20:0009 */
+
+#endif /* __GCCXML_WTF */
\ No newline at end of file
Index: yvals.h
===================================================================
--- yvals.h	(revision 91)
+++ yvals.h	(working copy)
@@ -243,6 +243,26 @@
 #endif
 
 
+/* ------------------------------------------------------------------------ */
+/* Forward declare these now because they are used as non-dependent names.  */
+#ifdef _DEBUG
+
+#if !defined(_NATIVE_WCHAR_T_DEFINED) && defined(_M_CEE_PURE)
+extern "C++"
+#else
+extern "C"
+#endif
+_CRTIMP void __cdecl _invalid_parameter(_In_opt_z_ const wchar_t *, _In_opt_z_ const wchar_t *, _In_opt_z_ const wchar_t *, unsigned int, uintptr_t);
+
+#else /* _DEBUG */
+
+extern "C"
+_CRTIMP void __cdecl _invalid_parameter_noinfo(void);
+
+#endif /* def _DEBUG */
+/* ------------------------------------------------------------------------ */
+
+
  #if _SECURE_SCL_THROWS
 
  #ifndef _SILENCE_DEPRECATION_OF_SECURE_SCL_THROWS
@@ -540,8 +560,8 @@
 		/* VC++ COMPILER PARAMETERS */
 #define _LONGLONG	__int64
 #define _ULONGLONG	unsigned __int64
-#define _LLONG_MAX	0x7fffffffffffffff
-#define _ULLONG_MAX	0xffffffffffffffff
+#define _LLONG_MAX	0x7fffffffffffffffi64
+#define _ULLONG_MAX	0xffffffffffffffffui64
 
 		/* INTEGER PROPERTIES */
 #define _C2			1	/* 0 if not 2's complement */
@@ -633,10 +653,10 @@
     static _MRTIMP2_NPURE void __cdecl _Lockit_ctor(_Lockit *);
     static _MRTIMP2_NPURE void __cdecl _Lockit_ctor(_Lockit *, int);
     static _MRTIMP2_NPURE void __cdecl _Lockit_dtor(_Lockit *);
-
+/*
 	__CLR_OR_THIS_CALL _Lockit(const _Lockit&);				// not defined
 	_Lockit& __CLR_OR_THIS_CALL operator=(const _Lockit&);	// not defined
-
+*/
 	int _Locktype;
 
   #else /* _MULTI_THREAD */
